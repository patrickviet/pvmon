
var si = {};

function now() {
	return (new Date().getTime());
}

module.exports.insert_event = function(ev) {

	// I need here:
	// base riemann.io inspired model: host, service, state, time, metric, ttl
	// pvmon var: exec
	// AND three extra params: (ri meaning rolling state)
	// rs_max_crit, rs_max_warn, rs_length

	// the valid states are ok, warn, crit. Anything else will be modified to
	// crit

	var key = ev.host + '/' + ev.service;
	var state = ev.state;
	if(ev.state != 'ok' && ev.state != 'warn') { ev.state = 'crit'; }

	var rs_timeframe = ev.exec_interval * ev.rs_length * 2000;


	// if the event is too old...
	// must divide by 1000 (milliseconds > seconds for UNIX EPOCH)
	if (ev.time < ((now() - rs_timeframe)/1000)) {
		// ignore the event
		return;
	}

	// update the state

	// first initialize the event just in case it's empty
	if(!si.hasOwnProperty(key)) {
		si[key] = {
			data: [],
			state: 'ok',
		};
	}

	// expiration
	si[key].expire = now() + rs_timeframe;

	// adjust length
	while(si[key].data.length < (ev.rs_length - 1)) {
		si[key].data.unshift('ok');
	}	
	while(si[key].data.length >= (ev.rs_length)) {
		si[key].data.shift();
	}

	// and put data in!
	si[key].data.push(state);

	// -------------------------------------------------------------------------
	// this is the 'big' part: match against limits of pattern

	var count_warn = 0, count_crit = 0;
	si[key].data.forEach(function(v) { if(v == 'crit') count_crit++; else if (v == 'warn') { count_warn++; }});

	var old_state = si[key].state;
	var new_state = old_state;

	if(old_state != 'ok') {
		if ((count_crit + count_warn >= ev.rs_max_crit) && (count_crit)) { new_state = 'crit'; }

		// can restore to ok?
		var last_ok_count = 0;
		for(i = si[key].data.length-1 ; i >= 0 ; i--) { if (si[key].data[i] == 'ok') { last_ok_count++; } else { break; }}
		if (((last_ok_count > ev.rs_max_warn) && (last_ok_count > ev.rs_max_crit)) || (last_ok_count >= ev.rs_length)) {
			// put all checks to OK
			for(i = 0 ; i <= ev.rs_length ; i++) { si[key].data[i] = 'ok'; }
			new_state = 'ok';
		}
	} else {
		if (count_crit + count_warn >= ev.rs_max_warn) { new_state = 'warn'; }
		if ((count_crit + count_warn >= ev.rs_max_crit) && (count_crit)) { new_state = 'crit'; } 
	}

	if(old_state != new_state) {
		si[key].state = new_state;
		console.log(key+': change state from '+old_state+' to '+new_state+' - '+si[key].data.join(','));
	} else {
		console.log(key+': no change ('+new_state+') - '+si[key].data.join(','));
	}
}