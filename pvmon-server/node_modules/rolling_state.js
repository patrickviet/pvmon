
// the 'big' state index
var si = {};

// indexed by host and by service ...
var si_by_host = {};
var si_by_service = {};

//setInterval(console.log,5000,si);

function now() {
	return (new Date().getTime());
}

function check_for_timeout(host,service) {
	var fullsrv = host+'/'+service;
	if(si.hasOwnProperty(fullsrv)) {
		var n = now();
		if (si[fullsrv].expire <= n) {
			// timeout!!
			console.log('timeout for '+fullsrv+' '+n+' is later than '+si[fullsrv].expire);

			if(si[fullsrv].persistent) {
				// it's a persistent event (ie. a hello)
				// this means I must raise an alert if I haven't received this - and keep it
				console.log('this event is persistent - we need to keep it - raising alert');

				// throw/update last event back in, with crit state
				var unix_stamp = Math.round(now()/1000);

				si[fullsrv].last_ev.state = 'crit';
				si[fullsrv].last_ev.time = unix_stamp;
				si[fullsrv].last_ev.description = 'auto timeout message from '+host+'/'+service;

				// we must not send anymore timeouts for now - I add a condition for this.
				si[fullsrv].last_ev.is_timeout = true;

				setTimeout(module.exports.insert_event,0,si[fullsrv].last_ev);



			} else {
				// this is a transiet event
				// silently destroy it from the index
				console.log('transient event - just deleting it');

				delete si[fullsrv];
				delete si_by_host[host][service];
				delete si_by_service[service][host];			
			}

			

		}
	} else {
		// set another timeout to check later instead at the proper interval
		si[fullsrv].timer = setTimeout(check_for_timeout,si[fullsrv].exec_interval*1000,host,service);
	}
}

// ----------------------------------------------------------------------------

module.exports.state_change = function(ev) {

	console.log('state_change');
	console.log(ev);

	// push it to SQL right away ...

}

module.exports.insert_event = function(ev) {

	// I need here:
	// base riemann.io inspired model: host, service, state, time, metric, ttl
	// pvmon var: exec
	// AND three extra params: (ri meaning rolling state)
	// rs_max_crit, rs_max_warn, rs_length

	// the valid states are ok, warn, crit. Anything else will be modified to
	// crit

	var key = ev.host + '/' + ev.service;
	var state = ev.state;
	if(ev.state != 'ok' && ev.state != 'warn') { ev.state = 'crit'; }

	var rs_timeframe = ev.exec_interval * ev.rs_length * 2000;


	// if the event is too old...
	// must divide by 1000 (milliseconds > seconds for UNIX EPOCH)
	if (ev.time < ((now() - rs_timeframe)/1000)) {
		// ignore the event
		return;
	}

	// update the state

	// first initialize the event just in case it's empty
	if(!si.hasOwnProperty(key)) {
		si[key] = {
			data: [],
			state: 'ok',
			timer: 0,
		};

		// and set our indexes

		// indexed hosts
		if(!si_by_host.hasOwnProperty(ev.host)) {
			si_by_host[ev.host] = {};
		}
		si_by_host[ev.host][ev.service] = si[key];

		// indexed services
		if(!si_by_service.hasOwnProperty(ev.service)) {
			si_by_service[ev.service] = {};
		}
		si_by_service[ev.service][ev.host] = si[key];

	}

	// expiration
	si[key].expire = now() + rs_timeframe;

	// timer for expiration
	if(!ev.hasOwnProperty('is_timeout')) { ev.is_timeout = 0; }
	
	if(ev.rs_persistent) { si[key].persistent = true; }
	else { si[key].persistent = false; }

	if(!ev.is_timeout) {
		if(si[key].timer) { clearTimeout(si[key].timer); }
		si[key].timer = setTimeout(check_for_timeout,rs_timeframe,ev.host,ev.service);
		si[key].exec_interval = ev.exec_interval;
	}

	// adjust length
	while(si[key].data.length < (ev.rs_length - 1)) {
		si[key].data.unshift('ok');
	}	
	while(si[key].data.length >= (ev.rs_length)) {
		si[key].data.shift();
	}

	// put state in!
	si[key].data.push(state);

	// insert last event to save it
	si[key].last_ev = ev;

	// -------------------------------------------------------------------------
	// this is the 'big' part: match against limits of pattern

	var count_warn = 0, count_crit = 0;
	si[key].data.forEach(function(v) { if(v == 'crit') count_crit++; else if (v == 'warn') { count_warn++; }});

	var old_state = si[key].state;
	var new_state = old_state;

	if(old_state != 'ok') {
		if ((count_crit + count_warn >= ev.rs_max_crit) && (count_crit)) { new_state = 'crit'; }

		// can restore to ok?
		var last_ok_count = 0;
		for(i = si[key].data.length-1 ; i >= 0 ; i--) { if (si[key].data[i] == 'ok') { last_ok_count++; } else { break; }}
		if (((last_ok_count > ev.rs_max_warn) && (last_ok_count > ev.rs_max_crit)) || (last_ok_count >= ev.rs_length)) {
			// put all checks to OK
			for(i = 0 ; i <= ev.rs_length ; i++) { si[key].data[i] = 'ok'; }
			new_state = 'ok';
		}
	} else {
		if (count_crit + count_warn >= ev.rs_max_warn) { new_state = 'warn'; }
		if ((count_crit + count_warn >= ev.rs_max_crit) && (count_crit)) { new_state = 'crit'; } 
	}

	if(old_state != new_state) {
		si[key].state = new_state;
		console.log(key+': change state from '+old_state+' to '+new_state+' - '+si[key].data.join(','));
		module.exports.state_change(ev);
	} else {
		console.log(now()+' '+key+': no change ('+new_state+') - '+si[key].data.join(','));
	}
}


module.exports.get_states = function(){
	console.log(si);
}