
// the 'big' state index
var si = {};

// indexed by host and by service ...
var si_by_host = {};
var si_by_service = {};

//setInterval(console.log,5000,si);



module.exports.get_state = function(host_list,service_list) {

	var service_list_calc = {};
	var host_list_calc = {};

	var ret = { 'now': now(), state: {} };

	ret.flatpush = function(host,service) {
		var k = host+'/'+service;
		var obj = si[k];
		ret.state[k] = { 'host': host, 'service':service };

		service_list_calc[service] = 1;
		host_list_calc[host] = 1;

		for(var i in obj) {
			if(obj.hasOwnProperty(i) && i != 'timer') {
				if(i == 'last_ev') {
					// flatten
					for(var j in obj[i]) {
						if(obj[i].hasOwnProperty(j)) {
							ret.state[k][j] = obj[i][j];
						}
					}
				} else {
					ret.state[k][i] = obj[i];	
				}
			}
		}
	};


	if(host_list.length) {
		host_list.forEach(function(host) {
			console.log('process '+host);
			if(si_by_host.hasOwnProperty(host)) {
				console.log('add '+host);
				if(service_list.length) {
					Object.keys(si_by_host[host]).forEach(function(service) { 
						if(si_by_host[host].hasOwnProperty(service)) {
							ret.flatpush(host,service);
						}
					});
				} else {
					Object.keys(si_by_host[host]).forEach(function(service) {
						ret.flatpush(host,service);
					});
				}
				
			}
			
		});
	}
	else if (service_list.length) {
		// this case is always ONLY service since the host/service is handled earlier
		service_list.forEach(function(service) {
			if(si_by_service.hasOwnProperty(service)) {
				Object.keys(si_by_service[service]).forEach(function(host) {
					ret.flatpush(host,service);
				});
			}
			
		});

	} else {
		// full dump
		Object.keys(si_by_host).forEach(function(host) {
			Object.keys(si_by_host[host]).forEach(function(service) {
				ret.flatpush(host,service);
			});
		});
	}

	delete ret['flatpush'];
	ret.host = Object.keys(host_list_calc);
	ret.service = Object.keys(service_list_calc);

	return ret;
};

module.exports.get_host_list = function(pattern) {
	if(pattern) {
		var ret = [];
		Object.keys(si_by_host).forEach(function(elem) {
			if(elem.match(pattern)) {
				ret.push(elem);
			}
		});
		return ret;
	} else {
		return Object.keys(si_by_host);
	}
};

module.exports.get_service_list = function(pattern) {
	if(pattern) {
		var ret = [];
		Object.keys(si_by_service).forEach(function(elem) {
			if(elem.match(pattern)) {
				ret.push(elem);
			}
		});
		return ret;
	} else {
		return Object.keys(si_by_service);
	}
};

function now() {
	return (new Date().getTime());
}

function check_for_timeout(host,service) {
	var fullsrv = host+'/'+service;
	if(si.hasOwnProperty(fullsrv)) {
		var n = now();
		if (si[fullsrv].expire <= n) {
			// timeout!!
			console.log('timeout for '+fullsrv+' '+n+' is later than '+si[fullsrv].expire);

			if(si[fullsrv].persistent) {
				// it's a persistent event (ie. a hello)
				// this means I must raise an alert if I haven't received this - and keep it
				console.log('this event is persistent - we need to keep it - raising alert');

				// throw/update last event back in, with crit state
				var unix_stamp = Math.round(now()/1000);

				si[fullsrv].last_ev.state = 'crit';
				si[fullsrv].last_ev.time = unix_stamp;
				si[fullsrv].last_ev.description = 'auto timeout message from '+host+'/'+service;

				// we must not send anymore timeouts for now - I add a condition for this.
				si[fullsrv].last_ev.is_timeout = true;

				setTimeout(module.exports.insert_event,0,si[fullsrv].last_ev);



			} else {
				// this is a transiet event
				// silently destroy it from the index
				console.log('transient event - just deleting it');

				delete si[fullsrv];
				delete si_by_host[host][service];
				delete si_by_service[service][host];			
			}

			

		}
	} else {
		// set another timeout to check later instead at the proper interval
		si[fullsrv].timer = setTimeout(check_for_timeout,si[fullsrv].exec_interval*1000,host,service);
	}
}

// ----------------------------------------------------------------------------

module.exports.state_change = function(ev) {

	console.log('state_change');
	console.log(ev);

	// push it to SQL right away ...

}

module.exports.insert_event = function(ev) {

	// I need here:
	// base riemann.io inspired model: host, service, state, time, metric, ttl
	// pvmon var: exec
	// AND three extra params: (ri meaning rolling state)
	// rs_max_crit, rs_max_warn, rs_length

	// the valid states are ok, warn, crit. Anything else will be modified to
	// crit

	var key = ev.host + '/' + ev.service;
	var state = ev.state;
	if(ev.state != 'ok' && ev.state != 'warn') { ev.state = 'crit'; }

	var rs_timeframe = ev.exec_interval * ev.rs_length * 2000;


	// if the event is too old...
	// must divide by 1000 (milliseconds > seconds for UNIX EPOCH)
	if (ev.time < ((now() - rs_timeframe)/1000)) {
		// ignore the event
		return;
	}

	// update the state

	// first initialize the event just in case it's empty
	if(!si.hasOwnProperty(key)) {
		si[key] = {
			data: [],
			state: 'ok',
			timer: 0,
		};

		// and set our indexes

		// indexed hosts
		if(!si_by_host.hasOwnProperty(ev.host)) {
			si_by_host[ev.host] = {};
		}
		si_by_host[ev.host][ev.service] = si[key];

		// indexed services
		if(!si_by_service.hasOwnProperty(ev.service)) {
			si_by_service[ev.service] = {};
		}
		si_by_service[ev.service][ev.host] = si[key];

	}

	// expiration
	si[key].expire = now() + rs_timeframe;

	// timer for expiration
	if(!ev.hasOwnProperty('is_timeout')) { ev.is_timeout = 0; }
	
	if(ev.rs_persistent) { si[key].persistent = true; }
	else { si[key].persistent = false; }

	if(!ev.is_timeout) {
		if(si[key].timer) { clearTimeout(si[key].timer); }
		si[key].timer = setTimeout(check_for_timeout,rs_timeframe,ev.host,ev.service);
		si[key].exec_interval = ev.exec_interval;
	}

	// adjust length
	while(si[key].data.length < (ev.rs_length - 1)) {
		si[key].data.unshift('ok');
	}	
	while(si[key].data.length >= (ev.rs_length)) {
		si[key].data.shift();
	}

	// put state in!
	si[key].data.push(state);

	// insert last event to save it
	si[key].last_ev = ev;

	// -------------------------------------------------------------------------
	// this is the 'big' part: match against limits of pattern

	var count_warn = 0, count_crit = 0;
	si[key].data.forEach(function(v) { if(v == 'crit') count_crit++; else if (v == 'warn') { count_warn++; }});

	var old_state = si[key].state;
	var new_state = old_state;

	if(old_state != 'ok') {
		if ((count_crit + count_warn >= ev.rs_max_crit) && (count_crit)) { new_state = 'crit'; }

		// can restore to ok?
		var last_ok_count = 0;
		for(i = si[key].data.length-1 ; i >= 0 ; i--) { if (si[key].data[i] == 'ok') { last_ok_count++; } else { break; }}
		if (((last_ok_count > ev.rs_max_warn) && (last_ok_count > ev.rs_max_crit)) || (last_ok_count >= ev.rs_length)) {
			// put all checks to OK
			for(i = 0 ; i <= ev.rs_length ; i++) { si[key].data[i] = 'ok'; }
			new_state = 'ok';
		}
	} else {
		if (count_crit + count_warn >= ev.rs_max_warn) { new_state = 'warn'; }
		if ((count_crit + count_warn >= ev.rs_max_crit) && (count_crit)) { new_state = 'crit'; } 
	}

	if(old_state != new_state) {
		si[key].state = new_state;
		console.log(key+': change state from '+old_state+' to '+new_state+' - '+si[key].data.join(','));
		module.exports.state_change(ev);
	} else {
		console.log(now()+' '+key+': no change ('+new_state+') - '+si[key].data.join(','));
	}
}


module.exports.get_states = function(){
	console.log(si);
}